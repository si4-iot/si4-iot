{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar OctetstreamCodec = function () {\n  function OctetstreamCodec() {}\n\n  OctetstreamCodec.prototype.getMediaType = function () {\n    return 'application/octet-stream';\n  };\n\n  OctetstreamCodec.prototype.bytesToValue = function (bytes, schema, parameters) {\n    var bigendian = parameters.byteorder ? parameters.byteorder === \"bigendian\" : true;\n    var signed = parameters.signed ? parameters.signed === \"true\" : false;\n\n    if (parameters.length && parseInt(parameters.length) !== bytes.length) {\n      throw new Error(\"Lengths do not match, required: \" + parameters.length + \" provided: \" + bytes.length);\n    }\n\n    switch (schema.type) {\n      case \"boolean\":\n        return !bytes.every(function (val) {\n          return val == 0;\n        });\n\n      case \"integer\":\n        switch (bytes.length) {\n          case 1:\n            return signed ? bytes.readInt8(0) : bytes.readUInt8(0);\n\n          case 2:\n            return bigendian ? signed ? bytes.readInt16BE(0) : bytes.readUInt16BE(0) : signed ? bytes.readInt16LE(0) : bytes.readUInt16LE(0);\n\n          case 4:\n            return bigendian ? signed ? bytes.readInt32BE(0) : bytes.readUInt32BE(0) : signed ? bytes.readInt32LE(0) : bytes.readUInt32LE(0);\n\n          default:\n            var result = 0;\n            var negative = void 0;\n\n            if (bigendian) {\n              result = bytes.reduce(function (prev, curr, ix, arr) {\n                return prev << 8 + curr;\n              });\n              negative = bytes.readInt8(0) < 0;\n            } else {\n              result = bytes.reduceRight(function (prev, curr, ix, arr) {\n                return prev << 8 + curr;\n              });\n              negative = bytes.readInt8(bytes.length - 1) < 0;\n            }\n\n            if (signed && negative) {\n              result -= 1 << 8 * bytes.length;\n            }\n\n            if (!Number.isSafeInteger(result)) {\n              console.warn(\"Result is not a safe integer\");\n            }\n\n            return result;\n        }\n\n      case \"number\":\n        switch (bytes.length) {\n          case 4:\n            return bigendian ? bytes.readFloatBE(0) : bytes.readFloatLE(0);\n\n          case 8:\n            return bigendian ? bytes.readDoubleBE(0) : bytes.readDoubleLE(0);\n\n          default:\n            throw new Error(\"Wrong buffer length for type 'number', must be 4 or 8, is \" + bytes.length);\n        }\n\n      case \"string\":\n        return bytes.toString(parameters.charset);\n\n      case \"array\":\n      case \"object\":\n        throw new Error(\"Unable to handle object type \" + schema.type);\n\n      case \"null\":\n        return null;\n    }\n\n    throw new Error(\"Unknown object type\");\n  };\n\n  OctetstreamCodec.prototype.valueToBytes = function (value, schema, parameters) {\n    if (parameters.length === null) {\n      throw new Error(\"Missing 'length' parameter necessary for write\");\n    }\n\n    var bigendian = parameters.byteorder ? parameters.byteorder === \"bigendian\" : true;\n    var signed = parameters.signed ? parameters.signed === \"true\" : false;\n    var length = parseInt(parameters.length);\n    var buf;\n\n    if (value === undefined) {\n      throw new Error(\"Undefined value\");\n    }\n\n    switch (schema.type) {\n      case \"boolean\":\n        return Buffer.alloc(length, value ? 255 : 0);\n\n      case \"integer\":\n        if (typeof value !== \"number\") {\n          throw new Error(\"Value is not a number\");\n        }\n\n        if (!Number.isSafeInteger(value)) {\n          console.warn(\"Value is not a safe integer\");\n        }\n\n        if (signed) {\n          if (value < -(1 << 8 * length - 1) || value >= 1 << 8 * length - 1) {\n            throw new Error(\"Integer overflow when representing signed \" + value + \" in \" + length + \" byte(s)\");\n          }\n        } else {\n          if (value < 0 || value >= 1 << 8 * length) {\n            throw new Error(\"Integer overflow when representing unsigned \" + value + \" in \" + length + \" byte(s)\");\n          }\n        }\n\n        buf = Buffer.alloc(length);\n\n        switch (length) {\n          case 1:\n            signed ? buf.writeInt8(value, 0) : buf.writeUInt8(value, 0);\n            break;\n\n          case 2:\n            bigendian ? signed ? buf.writeInt16BE(value, 0) : buf.writeUInt16BE(value, 0) : signed ? buf.writeInt16LE(value, 0) : buf.writeUInt16LE(value, 0);\n            break;\n\n          case 4:\n            bigendian ? signed ? buf.writeInt32BE(value, 0) : buf.writeUInt32BE(value, 0) : signed ? buf.writeInt32LE(value, 0) : buf.writeUInt32LE(value, 0);\n            break;\n\n          default:\n            if (signed && value < 0) {\n              value += 1 << 8 * length;\n            }\n\n            for (var i = 0; i < length; ++i) {\n              var byte = value % 0x100;\n              value /= 0x100;\n              buf.writeInt8(byte, bigendian ? length - i - 1 : i);\n            }\n\n        }\n\n        return buf;\n\n      case \"number\":\n        if (typeof value !== \"number\") {\n          throw new Error(\"Value is not a number\");\n        }\n\n        buf = Buffer.alloc(length);\n\n        switch (length) {\n          case 4:\n            bigendian ? buf.writeFloatBE(value, 0) : buf.writeFloatLE(value, 0);\n            break;\n\n          case 8:\n            bigendian ? buf.writeDoubleBE(value, 0) : buf.writeDoubleLE(value, 0);\n            break;\n\n          default:\n            throw new Error(\"Wrong buffer length for type 'number', must be 4 or 8, is \" + length);\n        }\n\n        return buf;\n\n      case \"string\":\n        var str = String(value);\n        return Buffer.from(str);\n\n      case \"array\":\n      case \"object\":\n        throw new Error(\"Unable to handle object type \" + schema.type);\n\n      case \"null\":\n        return null;\n    }\n\n    throw new Error(\"Unknown object type\");\n  };\n\n  return OctetstreamCodec;\n}();\n\nexports.default = OctetstreamCodec;","map":null,"metadata":{},"sourceType":"script"}