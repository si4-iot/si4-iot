{"ast":null,"code":"/*global unescape, module, define, window, global*/\n\n/*\r\n UriTemplate Copyright (c) 2012-2013 Franz Antesberger. All Rights Reserved.\r\n Available via the MIT license.\r\n*/\n(function (exportCallback) {\n  \"use strict\";\n\n  var UriTemplateError = function () {\n    function UriTemplateError(options) {\n      this.options = options;\n    }\n\n    UriTemplateError.prototype.toString = function () {\n      if (JSON && JSON.stringify) {\n        return JSON.stringify(this.options);\n      } else {\n        return this.options;\n      }\n    };\n\n    return UriTemplateError;\n  }();\n\n  var objectHelper = function () {\n    function isArray(value) {\n      return Object.prototype.toString.apply(value) === '[object Array]';\n    }\n\n    function isString(value) {\n      return Object.prototype.toString.apply(value) === '[object String]';\n    }\n\n    function isNumber(value) {\n      return Object.prototype.toString.apply(value) === '[object Number]';\n    }\n\n    function isBoolean(value) {\n      return Object.prototype.toString.apply(value) === '[object Boolean]';\n    }\n\n    function join(arr, separator) {\n      var result = '',\n          first = true,\n          index;\n\n      for (index = 0; index < arr.length; index += 1) {\n        if (first) {\n          first = false;\n        } else {\n          result += separator;\n        }\n\n        result += arr[index];\n      }\n\n      return result;\n    }\n\n    function map(arr, mapper) {\n      var result = [],\n          index = 0;\n\n      for (; index < arr.length; index += 1) {\n        result.push(mapper(arr[index]));\n      }\n\n      return result;\n    }\n\n    function filter(arr, predicate) {\n      var result = [],\n          index = 0;\n\n      for (; index < arr.length; index += 1) {\n        if (predicate(arr[index])) {\n          result.push(arr[index]);\n        }\n      }\n\n      return result;\n    }\n\n    function deepFreezeUsingObjectFreeze(object) {\n      if (typeof object !== \"object\" || object === null) {\n        return object;\n      }\n\n      Object.freeze(object);\n      var property, propertyName;\n\n      for (propertyName in object) {\n        if (object.hasOwnProperty(propertyName)) {\n          property = object[propertyName]; // be aware, arrays are 'object', too\n\n          if (typeof property === \"object\") {\n            deepFreeze(property);\n          }\n        }\n      }\n\n      return object;\n    }\n\n    function deepFreeze(object) {\n      if (typeof Object.freeze === 'function') {\n        return deepFreezeUsingObjectFreeze(object);\n      }\n\n      return object;\n    }\n\n    return {\n      isArray: isArray,\n      isString: isString,\n      isNumber: isNumber,\n      isBoolean: isBoolean,\n      join: join,\n      map: map,\n      filter: filter,\n      deepFreeze: deepFreeze\n    };\n  }();\n\n  var charHelper = function () {\n    function isAlpha(chr) {\n      return chr >= 'a' && chr <= 'z' || chr >= 'A' && chr <= 'Z';\n    }\n\n    function isDigit(chr) {\n      return chr >= '0' && chr <= '9';\n    }\n\n    function isHexDigit(chr) {\n      return isDigit(chr) || chr >= 'a' && chr <= 'f' || chr >= 'A' && chr <= 'F';\n    }\n\n    return {\n      isAlpha: isAlpha,\n      isDigit: isDigit,\n      isHexDigit: isHexDigit\n    };\n  }();\n\n  var pctEncoder = function () {\n    var utf8 = {\n      encode: function (chr) {\n        // see http://ecmanaut.blogspot.de/2006/07/encoding-decoding-utf8-in-javascript.html\n        return unescape(encodeURIComponent(chr));\n      },\n      numBytes: function (firstCharCode) {\n        if (firstCharCode <= 0x7F) {\n          return 1;\n        } else if (0xC2 <= firstCharCode && firstCharCode <= 0xDF) {\n          return 2;\n        } else if (0xE0 <= firstCharCode && firstCharCode <= 0xEF) {\n          return 3;\n        } else if (0xF0 <= firstCharCode && firstCharCode <= 0xF4) {\n          return 4;\n        } // no valid first octet\n\n\n        return 0;\n      },\n      isValidFollowingCharCode: function (charCode) {\n        return 0x80 <= charCode && charCode <= 0xBF;\n      }\n    };\n    /**\r\n     * encodes a character, if needed or not.\r\n     * @param chr\r\n     * @return pct-encoded character\r\n     */\n\n    function encodeCharacter(chr) {\n      var result = '',\n          octets = utf8.encode(chr),\n          octet,\n          index;\n\n      for (index = 0; index < octets.length; index += 1) {\n        octet = octets.charCodeAt(index);\n        result += '%' + (octet < 0x10 ? '0' : '') + octet.toString(16).toUpperCase();\n      }\n\n      return result;\n    }\n    /**\r\n     * Returns, whether the given text at start is in the form 'percent hex-digit hex-digit', like '%3F'\r\n     * @param text\r\n     * @param start\r\n     * @return {boolean|*|*}\r\n     */\n\n\n    function isPercentDigitDigit(text, start) {\n      return text.charAt(start) === '%' && charHelper.isHexDigit(text.charAt(start + 1)) && charHelper.isHexDigit(text.charAt(start + 2));\n    }\n    /**\r\n     * Parses a hex number from start with length 2.\r\n     * @param text a string\r\n     * @param start the start index of the 2-digit hex number\r\n     * @return {Number}\r\n     */\n\n\n    function parseHex2(text, start) {\n      return parseInt(text.substr(start, 2), 16);\n    }\n    /**\r\n     * Returns whether or not the given char sequence is a correctly pct-encoded sequence.\r\n     * @param chr\r\n     * @return {boolean}\r\n     */\n\n\n    function isPctEncoded(chr) {\n      if (!isPercentDigitDigit(chr, 0)) {\n        return false;\n      }\n\n      var firstCharCode = parseHex2(chr, 1);\n      var numBytes = utf8.numBytes(firstCharCode);\n\n      if (numBytes === 0) {\n        return false;\n      }\n\n      for (var byteNumber = 1; byteNumber < numBytes; byteNumber += 1) {\n        if (!isPercentDigitDigit(chr, 3 * byteNumber) || !utf8.isValidFollowingCharCode(parseHex2(chr, 3 * byteNumber + 1))) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n    /**\r\n     * Reads as much as needed from the text, e.g. '%20' or '%C3%B6'. It does not decode!\r\n     * @param text\r\n     * @param startIndex\r\n     * @return the character or pct-string of the text at startIndex\r\n     */\n\n\n    function pctCharAt(text, startIndex) {\n      var chr = text.charAt(startIndex);\n\n      if (!isPercentDigitDigit(text, startIndex)) {\n        return chr;\n      }\n\n      var utf8CharCode = parseHex2(text, startIndex + 1);\n      var numBytes = utf8.numBytes(utf8CharCode);\n\n      if (numBytes === 0) {\n        return chr;\n      }\n\n      for (var byteNumber = 1; byteNumber < numBytes; byteNumber += 1) {\n        if (!isPercentDigitDigit(text, startIndex + 3 * byteNumber) || !utf8.isValidFollowingCharCode(parseHex2(text, startIndex + 3 * byteNumber + 1))) {\n          return chr;\n        }\n      }\n\n      return text.substr(startIndex, 3 * numBytes);\n    }\n\n    return {\n      encodeCharacter: encodeCharacter,\n      isPctEncoded: isPctEncoded,\n      pctCharAt: pctCharAt\n    };\n  }();\n\n  var rfcCharHelper = function () {\n    /**\r\n     * Returns if an character is an varchar character according 2.3 of rfc 6570\r\n     * @param chr\r\n     * @return (Boolean)\r\n     */\n    function isVarchar(chr) {\n      return charHelper.isAlpha(chr) || charHelper.isDigit(chr) || chr === '_' || pctEncoder.isPctEncoded(chr);\n    }\n    /**\r\n     * Returns if chr is an unreserved character according 1.5 of rfc 6570\r\n     * @param chr\r\n     * @return {Boolean}\r\n     */\n\n\n    function isUnreserved(chr) {\n      return charHelper.isAlpha(chr) || charHelper.isDigit(chr) || chr === '-' || chr === '.' || chr === '_' || chr === '~';\n    }\n    /**\r\n     * Returns if chr is an reserved character according 1.5 of rfc 6570\r\n     * or the percent character mentioned in 3.2.1.\r\n     * @param chr\r\n     * @return {Boolean}\r\n     */\n\n\n    function isReserved(chr) {\n      return chr === ':' || chr === '/' || chr === '?' || chr === '#' || chr === '[' || chr === ']' || chr === '@' || chr === '!' || chr === '$' || chr === '&' || chr === '(' || chr === ')' || chr === '*' || chr === '+' || chr === ',' || chr === ';' || chr === '=' || chr === \"'\";\n    }\n\n    return {\n      isVarchar: isVarchar,\n      isUnreserved: isUnreserved,\n      isReserved: isReserved\n    };\n  }();\n  /**\r\n   * encoding of rfc 6570\r\n   */\n\n\n  var encodingHelper = function () {\n    function encode(text, passReserved) {\n      var result = '',\n          index,\n          chr = '';\n\n      if (typeof text === \"number\" || typeof text === \"boolean\") {\n        text = text.toString();\n      }\n\n      for (index = 0; index < text.length; index += chr.length) {\n        chr = text.charAt(index);\n        result += rfcCharHelper.isUnreserved(chr) || passReserved && rfcCharHelper.isReserved(chr) ? chr : pctEncoder.encodeCharacter(chr);\n      }\n\n      return result;\n    }\n\n    function encodePassReserved(text) {\n      return encode(text, true);\n    }\n\n    function encodeLiteralCharacter(literal, index) {\n      var chr = pctEncoder.pctCharAt(literal, index);\n\n      if (chr.length > 1) {\n        return chr;\n      } else {\n        return rfcCharHelper.isReserved(chr) || rfcCharHelper.isUnreserved(chr) ? chr : pctEncoder.encodeCharacter(chr);\n      }\n    }\n\n    function encodeLiteral(literal) {\n      var result = '',\n          index,\n          chr = '';\n\n      for (index = 0; index < literal.length; index += chr.length) {\n        chr = pctEncoder.pctCharAt(literal, index);\n\n        if (chr.length > 1) {\n          result += chr;\n        } else {\n          result += rfcCharHelper.isReserved(chr) || rfcCharHelper.isUnreserved(chr) ? chr : pctEncoder.encodeCharacter(chr);\n        }\n      }\n\n      return result;\n    }\n\n    return {\n      encode: encode,\n      encodePassReserved: encodePassReserved,\n      encodeLiteral: encodeLiteral,\n      encodeLiteralCharacter: encodeLiteralCharacter\n    };\n  }(); // the operators defined by rfc 6570\n\n\n  var operators = function () {\n    var bySymbol = {};\n\n    function create(symbol) {\n      bySymbol[symbol] = {\n        symbol: symbol,\n        separator: symbol === '?' ? '&' : symbol === '' || symbol === '+' || symbol === '#' ? ',' : symbol,\n        named: symbol === ';' || symbol === '&' || symbol === '?',\n        ifEmpty: symbol === '&' || symbol === '?' ? '=' : '',\n        first: symbol === '+' ? '' : symbol,\n        encode: symbol === '+' || symbol === '#' ? encodingHelper.encodePassReserved : encodingHelper.encode,\n        toString: function () {\n          return this.symbol;\n        }\n      };\n    }\n\n    create('');\n    create('+');\n    create('#');\n    create('.');\n    create('/');\n    create(';');\n    create('?');\n    create('&');\n    return {\n      valueOf: function (chr) {\n        if (bySymbol[chr]) {\n          return bySymbol[chr];\n        }\n\n        if (\"=,!@|\".indexOf(chr) >= 0) {\n          return null;\n        }\n\n        return bySymbol[''];\n      }\n    };\n  }();\n  /**\r\n   * Detects, whether a given element is defined in the sense of rfc 6570\r\n   * Section 2.3 of the RFC makes clear defintions:\r\n   * * undefined and null are not defined.\r\n   * * the empty string is defined\r\n   * * an array (\"list\") is defined, if it is not empty (even if all elements are not defined)\r\n   * * an object (\"map\") is defined, if it contains at least one property with defined value\r\n   * @param object\r\n   * @return {Boolean}\r\n   */\n\n\n  function isDefined(object) {\n    var propertyName;\n\n    if (object === null || object === undefined) {\n      return false;\n    }\n\n    if (objectHelper.isArray(object)) {\n      // Section 2.3: A variable defined as a list value is considered undefined if the list contains zero members\n      return object.length > 0;\n    }\n\n    if (typeof object === \"string\" || typeof object === \"number\" || typeof object === \"boolean\") {\n      // falsy values like empty strings, false or 0 are \"defined\"\n      return true;\n    } // else Object\n\n\n    for (propertyName in object) {\n      if (object.hasOwnProperty(propertyName) && isDefined(object[propertyName])) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  var LiteralExpression = function () {\n    function LiteralExpression(literal) {\n      this.literal = encodingHelper.encodeLiteral(literal);\n    }\n\n    LiteralExpression.prototype.expand = function () {\n      return this.literal;\n    };\n\n    LiteralExpression.prototype.toString = LiteralExpression.prototype.expand;\n    return LiteralExpression;\n  }();\n\n  var parse = function () {\n    function parseExpression(expressionText) {\n      var operator,\n          varspecs = [],\n          varspec = null,\n          varnameStart = null,\n          maxLengthStart = null,\n          index,\n          chr = '';\n\n      function closeVarname() {\n        var varname = expressionText.substring(varnameStart, index);\n\n        if (varname.length === 0) {\n          throw new UriTemplateError({\n            expressionText: expressionText,\n            message: \"a varname must be specified\",\n            position: index\n          });\n        }\n\n        varspec = {\n          varname: varname,\n          exploded: false,\n          maxLength: null\n        };\n        varnameStart = null;\n      }\n\n      function closeMaxLength() {\n        if (maxLengthStart === index) {\n          throw new UriTemplateError({\n            expressionText: expressionText,\n            message: \"after a ':' you have to specify the length\",\n            position: index\n          });\n        }\n\n        varspec.maxLength = parseInt(expressionText.substring(maxLengthStart, index), 10);\n        maxLengthStart = null;\n      }\n\n      operator = function (operatorText) {\n        var op = operators.valueOf(operatorText);\n\n        if (op === null) {\n          throw new UriTemplateError({\n            expressionText: expressionText,\n            message: \"illegal use of reserved operator\",\n            position: index,\n            operator: operatorText\n          });\n        }\n\n        return op;\n      }(expressionText.charAt(0));\n\n      index = operator.symbol.length;\n      varnameStart = index;\n\n      for (; index < expressionText.length; index += chr.length) {\n        chr = pctEncoder.pctCharAt(expressionText, index);\n\n        if (varnameStart !== null) {\n          // the spec says: varname =  varchar *( [\".\"] varchar )\n          // so a dot is allowed except for the first char\n          if (chr === '.') {\n            if (varnameStart === index) {\n              throw new UriTemplateError({\n                expressionText: expressionText,\n                message: \"a varname MUST NOT start with a dot\",\n                position: index\n              });\n            }\n\n            continue;\n          }\n\n          if (rfcCharHelper.isVarchar(chr)) {\n            continue;\n          }\n\n          closeVarname();\n        }\n\n        if (maxLengthStart !== null) {\n          if (index === maxLengthStart && chr === '0') {\n            throw new UriTemplateError({\n              expressionText: expressionText,\n              message: \"A :prefix must not start with digit 0\",\n              position: index\n            });\n          }\n\n          if (charHelper.isDigit(chr)) {\n            if (index - maxLengthStart >= 4) {\n              throw new UriTemplateError({\n                expressionText: expressionText,\n                message: \"A :prefix must have max 4 digits\",\n                position: index\n              });\n            }\n\n            continue;\n          }\n\n          closeMaxLength();\n        }\n\n        if (chr === ':') {\n          if (varspec.maxLength !== null) {\n            throw new UriTemplateError({\n              expressionText: expressionText,\n              message: \"only one :maxLength is allowed per varspec\",\n              position: index\n            });\n          }\n\n          if (varspec.exploded) {\n            throw new UriTemplateError({\n              expressionText: expressionText,\n              message: \"an exploeded varspec MUST NOT be varspeced\",\n              position: index\n            });\n          }\n\n          maxLengthStart = index + 1;\n          continue;\n        }\n\n        if (chr === '*') {\n          if (varspec === null) {\n            throw new UriTemplateError({\n              expressionText: expressionText,\n              message: \"exploded without varspec\",\n              position: index\n            });\n          }\n\n          if (varspec.exploded) {\n            throw new UriTemplateError({\n              expressionText: expressionText,\n              message: \"exploded twice\",\n              position: index\n            });\n          }\n\n          if (varspec.maxLength) {\n            throw new UriTemplateError({\n              expressionText: expressionText,\n              message: \"an explode (*) MUST NOT follow to a prefix\",\n              position: index\n            });\n          }\n\n          varspec.exploded = true;\n          continue;\n        } // the only legal character now is the comma\n\n\n        if (chr === ',') {\n          varspecs.push(varspec);\n          varspec = null;\n          varnameStart = index + 1;\n          continue;\n        }\n\n        throw new UriTemplateError({\n          expressionText: expressionText,\n          message: \"illegal character\",\n          character: chr,\n          position: index\n        });\n      } // for chr\n\n\n      if (varnameStart !== null) {\n        closeVarname();\n      }\n\n      if (maxLengthStart !== null) {\n        closeMaxLength();\n      }\n\n      varspecs.push(varspec);\n      return new VariableExpression(expressionText, operator, varspecs);\n    }\n\n    function parse(uriTemplateText) {\n      // assert filled string\n      var index,\n          chr,\n          expressions = [],\n          braceOpenIndex = null,\n          literalStart = 0;\n\n      for (index = 0; index < uriTemplateText.length; index += 1) {\n        chr = uriTemplateText.charAt(index);\n\n        if (literalStart !== null) {\n          if (chr === '}') {\n            throw new UriTemplateError({\n              templateText: uriTemplateText,\n              message: \"unopened brace closed\",\n              position: index\n            });\n          }\n\n          if (chr === '{') {\n            if (literalStart < index) {\n              expressions.push(new LiteralExpression(uriTemplateText.substring(literalStart, index)));\n            }\n\n            literalStart = null;\n            braceOpenIndex = index;\n          }\n\n          continue;\n        }\n\n        if (braceOpenIndex !== null) {\n          // here just { is forbidden\n          if (chr === '{') {\n            throw new UriTemplateError({\n              templateText: uriTemplateText,\n              message: \"brace already opened\",\n              position: index\n            });\n          }\n\n          if (chr === '}') {\n            if (braceOpenIndex + 1 === index) {\n              throw new UriTemplateError({\n                templateText: uriTemplateText,\n                message: \"empty braces\",\n                position: braceOpenIndex\n              });\n            }\n\n            try {\n              expressions.push(parseExpression(uriTemplateText.substring(braceOpenIndex + 1, index)));\n            } catch (error) {\n              if (error.prototype === UriTemplateError.prototype) {\n                throw new UriTemplateError({\n                  templateText: uriTemplateText,\n                  message: error.options.message,\n                  position: braceOpenIndex + error.options.position,\n                  details: error.options\n                });\n              }\n\n              throw error;\n            }\n\n            braceOpenIndex = null;\n            literalStart = index + 1;\n          }\n\n          continue;\n        }\n\n        throw new Error('reached unreachable code');\n      }\n\n      if (braceOpenIndex !== null) {\n        throw new UriTemplateError({\n          templateText: uriTemplateText,\n          message: \"unclosed brace\",\n          position: braceOpenIndex\n        });\n      }\n\n      if (literalStart < uriTemplateText.length) {\n        expressions.push(new LiteralExpression(uriTemplateText.substr(literalStart)));\n      }\n\n      return new UriTemplate(uriTemplateText, expressions);\n    }\n\n    return parse;\n  }();\n\n  var VariableExpression = function () {\n    // helper function if JSON is not available\n    function prettyPrint(value) {\n      return JSON && JSON.stringify ? JSON.stringify(value) : value;\n    }\n\n    function isEmpty(value) {\n      if (!isDefined(value)) {\n        return true;\n      }\n\n      if (objectHelper.isString(value)) {\n        return value === '';\n      }\n\n      if (objectHelper.isNumber(value) || objectHelper.isBoolean(value)) {\n        return false;\n      }\n\n      if (objectHelper.isArray(value)) {\n        return value.length === 0;\n      }\n\n      for (var propertyName in value) {\n        if (value.hasOwnProperty(propertyName)) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    function propertyArray(object) {\n      var result = [],\n          propertyName;\n\n      for (propertyName in object) {\n        if (object.hasOwnProperty(propertyName)) {\n          result.push({\n            name: propertyName,\n            value: object[propertyName]\n          });\n        }\n      }\n\n      return result;\n    }\n\n    function VariableExpression(templateText, operator, varspecs) {\n      this.templateText = templateText;\n      this.operator = operator;\n      this.varspecs = varspecs;\n    }\n\n    VariableExpression.prototype.toString = function () {\n      return this.templateText;\n    };\n\n    function expandSimpleValue(varspec, operator, value) {\n      var result = '';\n      value = value.toString();\n\n      if (operator.named) {\n        result += encodingHelper.encodeLiteral(varspec.varname);\n\n        if (value === '') {\n          result += operator.ifEmpty;\n          return result;\n        }\n\n        result += '=';\n      }\n\n      if (varspec.maxLength !== null) {\n        value = value.substr(0, varspec.maxLength);\n      }\n\n      result += operator.encode(value);\n      return result;\n    }\n\n    function valueDefined(nameValue) {\n      return isDefined(nameValue.value);\n    }\n\n    function expandNotExploded(varspec, operator, value) {\n      var arr = [],\n          result = '';\n\n      if (operator.named) {\n        result += encodingHelper.encodeLiteral(varspec.varname);\n\n        if (isEmpty(value)) {\n          result += operator.ifEmpty;\n          return result;\n        }\n\n        result += '=';\n      }\n\n      if (objectHelper.isArray(value)) {\n        arr = value;\n        arr = objectHelper.filter(arr, isDefined);\n        arr = objectHelper.map(arr, operator.encode);\n        result += objectHelper.join(arr, ',');\n      } else {\n        arr = propertyArray(value);\n        arr = objectHelper.filter(arr, valueDefined);\n        arr = objectHelper.map(arr, function (nameValue) {\n          return operator.encode(nameValue.name) + ',' + operator.encode(nameValue.value);\n        });\n        result += objectHelper.join(arr, ',');\n      }\n\n      return result;\n    }\n\n    function expandExplodedNamed(varspec, operator, value) {\n      var isArray = objectHelper.isArray(value),\n          arr = [];\n\n      if (isArray) {\n        arr = value;\n        arr = objectHelper.filter(arr, isDefined);\n        arr = objectHelper.map(arr, function (listElement) {\n          var tmp = encodingHelper.encodeLiteral(varspec.varname);\n\n          if (isEmpty(listElement)) {\n            tmp += operator.ifEmpty;\n          } else {\n            tmp += '=' + operator.encode(listElement);\n          }\n\n          return tmp;\n        });\n      } else {\n        arr = propertyArray(value);\n        arr = objectHelper.filter(arr, valueDefined);\n        arr = objectHelper.map(arr, function (nameValue) {\n          var tmp = encodingHelper.encodeLiteral(nameValue.name);\n\n          if (isEmpty(nameValue.value)) {\n            tmp += operator.ifEmpty;\n          } else {\n            tmp += '=' + operator.encode(nameValue.value);\n          }\n\n          return tmp;\n        });\n      }\n\n      return objectHelper.join(arr, operator.separator);\n    }\n\n    function expandExplodedUnnamed(operator, value) {\n      var arr = [],\n          result = '';\n\n      if (objectHelper.isArray(value)) {\n        arr = value;\n        arr = objectHelper.filter(arr, isDefined);\n        arr = objectHelper.map(arr, operator.encode);\n        result += objectHelper.join(arr, operator.separator);\n      } else {\n        arr = propertyArray(value);\n        arr = objectHelper.filter(arr, function (nameValue) {\n          return isDefined(nameValue.value);\n        });\n        arr = objectHelper.map(arr, function (nameValue) {\n          return operator.encode(nameValue.name) + '=' + operator.encode(nameValue.value);\n        });\n        result += objectHelper.join(arr, operator.separator);\n      }\n\n      return result;\n    }\n\n    VariableExpression.prototype.expand = function (variables) {\n      var expanded = [],\n          index,\n          varspec,\n          value,\n          valueIsArr,\n          oneExploded = false,\n          operator = this.operator; // expand each varspec and join with operator's separator\n\n      for (index = 0; index < this.varspecs.length; index += 1) {\n        varspec = this.varspecs[index];\n        value = variables[varspec.varname]; // if (!isDefined(value)) {\n        // if (variables.hasOwnProperty(varspec.name)) {\n\n        if (value === null || value === undefined) {\n          continue;\n        }\n\n        if (varspec.exploded) {\n          oneExploded = true;\n        }\n\n        valueIsArr = objectHelper.isArray(value);\n\n        if (typeof value === \"string\" || typeof value === \"number\" || typeof value === \"boolean\") {\n          expanded.push(expandSimpleValue(varspec, operator, value));\n        } else if (varspec.maxLength && isDefined(value)) {\n          // 2.4.1 of the spec says: \"Prefix modifiers are not applicable to variables that have composite values.\"\n          throw new Error('Prefix modifiers are not applicable to variables that have composite values. You tried to expand ' + this + \" with \" + prettyPrint(value));\n        } else if (!varspec.exploded) {\n          if (operator.named || !isEmpty(value)) {\n            expanded.push(expandNotExploded(varspec, operator, value));\n          }\n        } else if (isDefined(value)) {\n          if (operator.named) {\n            expanded.push(expandExplodedNamed(varspec, operator, value));\n          } else {\n            expanded.push(expandExplodedUnnamed(operator, value));\n          }\n        }\n      }\n\n      if (expanded.length === 0) {\n        return \"\";\n      } else {\n        return operator.first + objectHelper.join(expanded, operator.separator);\n      }\n    };\n\n    return VariableExpression;\n  }();\n\n  var UriTemplate = function () {\n    function UriTemplate(templateText, expressions) {\n      this.templateText = templateText;\n      this.expressions = expressions;\n      objectHelper.deepFreeze(this);\n    }\n\n    UriTemplate.prototype.toString = function () {\n      return this.templateText;\n    };\n\n    UriTemplate.prototype.expand = function (variables) {\n      // this.expressions.map(function (expression) {return expression.expand(variables);}).join('');\n      var index,\n          result = '';\n\n      for (index = 0; index < this.expressions.length; index += 1) {\n        result += this.expressions[index].expand(variables);\n      }\n\n      return result;\n    };\n\n    UriTemplate.parse = parse;\n    UriTemplate.UriTemplateError = UriTemplateError;\n    return UriTemplate;\n  }();\n\n  exportCallback(UriTemplate);\n})(function (UriTemplate) {\n  \"use strict\"; // export UriTemplate, when module is present, or pass it to window or global\n\n  if (typeof module !== \"undefined\") {\n    module.exports = UriTemplate;\n  } else if (typeof define === \"function\") {\n    define([], function () {\n      return UriTemplate;\n    });\n  } else if (typeof window !== \"undefined\") {\n    window.UriTemplate = UriTemplate;\n  } else {\n    global.UriTemplate = UriTemplate;\n  }\n});","map":null,"metadata":{},"sourceType":"script"}